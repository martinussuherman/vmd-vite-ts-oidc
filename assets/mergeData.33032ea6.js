import{V as o,c as a,z as c,d as r,w as d,A as p}from"./main.1db1b49a.js";import{m as g,T as b}from"./mixins.920312b6.js";function h(e){return function(t,s){for(const i in s)Object.prototype.hasOwnProperty.call(t,i)||this.$delete(this.$data[e],i);for(const i in t)this.$set(this.$data[e],i,t[i])}}var y=o.extend({data:()=>({attrs$:{},listeners$:{}}),created(){this.$watch("$attrs",h("attrs$"),{immediate:!0}),this.$watch("$listeners",h("listeners$"),{immediate:!0})}}),v=o.extend({name:"colorable",props:{color:String},methods:{setBackgroundColor(e,t={}){return typeof t.style=="string"?(a("style must be an object",this),t):typeof t.class=="string"?(a("class must be an object",this),t):(c(e)?t.style={...t.style,"background-color":`${e}`,"border-color":`${e}`}:e&&(t.class={...t.class,[e]:!0}),t)},setTextColor(e,t={}){if(typeof t.style=="string")return a("style must be an object",this),t;if(typeof t.class=="string")return a("class must be an object",this),t;if(c(e))t.style={...t.style,color:`${e}`,"caret-color":`${e}`};else if(e){const[s,i]=e.toString().trim().split(" ",2);t.class={...t.class,[s+"--text"]:!0},i&&(t.class["text--"+i]=!0)}return t}}}),$=o.extend({name:"elevatable",props:{elevation:[Number,String]},computed:{computedElevation(){return this.elevation},elevationClasses(){const e=this.computedElevation;return e==null?{}:isNaN(parseInt(e))?{}:{[`elevation-${this.elevation}`]:!0}}}}),x=o.extend({name:"measurable",props:{height:[Number,String],maxHeight:[Number,String],maxWidth:[Number,String],minHeight:[Number,String],minWidth:[Number,String],width:[Number,String]},computed:{measurableStyles(){const e={},t=r(this.height),s=r(this.minHeight),i=r(this.minWidth),n=r(this.maxHeight),l=r(this.maxWidth),u=r(this.width);return t&&(e.height=t),s&&(e.minHeight=s),i&&(e.minWidth=i),n&&(e.maxHeight=n),l&&(e.maxWidth=l),u&&(e.width=u),e}}}),S=o.extend({name:"roundable",props:{rounded:[Boolean,String],tile:Boolean},computed:{roundedClasses(){const e=[],t=typeof this.rounded=="string"?String(this.rounded):this.rounded===!0;if(this.tile)e.push("rounded-0");else if(typeof t=="string"){const s=t.split(" ");for(const i of s)e.push(`rounded-${i}`)}else t&&e.push("rounded");return e.length>0?{[e.join(" ")]:!0}:{}}}}),B=g(y,v,$,x,S,b).extend({name:"v-sheet",props:{outlined:Boolean,shaped:Boolean,tag:{type:String,default:"div"}},computed:{classes(){return{"v-sheet":!0,"v-sheet--outlined":this.outlined,"v-sheet--shaped":this.shaped,...this.themeClasses,...this.elevationClasses,...this.roundedClasses}},styles(){return this.measurableStyles}},render(e){const t={class:this.classes,style:this.styles,on:this.listeners$};return e(this.tag,this.setBackgroundColor(this.color,t),this.$slots.default)}});const m={styleList:/;(?![^(]*\))/g,styleProp:/:(.*)/};function f(e){const t={};for(const s of e.split(m.styleList)){let[i,n]=s.split(m.styleProp);i=i.trim(),i&&(typeof n=="string"&&(n=n.trim()),t[p(i)]=n)}return t}function H(){const e={};let t=arguments.length,s;for(;t--;)for(s of Object.keys(arguments[t]))switch(s){case"class":case"directives":arguments[t][s]&&(e[s]=C(e[s],arguments[t][s]));break;case"style":arguments[t][s]&&(e[s]=k(e[s],arguments[t][s]));break;case"staticClass":if(!arguments[t][s])break;e[s]===void 0&&(e[s]=""),e[s]&&(e[s]+=" "),e[s]+=arguments[t][s].trim();break;case"on":case"nativeOn":arguments[t][s]&&(e[s]=w(e[s],arguments[t][s]));break;case"attrs":case"props":case"domProps":case"scopedSlots":case"staticStyle":case"hook":case"transition":if(!arguments[t][s])break;e[s]||(e[s]={}),e[s]={...arguments[t][s],...e[s]};break;default:e[s]||(e[s]=arguments[t][s])}return e}function k(e,t){return e?t?(e=d(typeof e=="string"?f(e):e),e.concat(typeof t=="string"?f(t):t)):e:t}function C(e,t){return t?e&&e?d(e).concat(t):t:e}function w(...e){if(!e[0])return e[1];if(!e[1])return e[0];const t={};for(let s=2;s--;){const i=e[s];for(const n in i)!i[n]||(t[n]?t[n]=[].concat(i[n],t[n]):t[n]=i[n])}return t}export{y as B,v as C,$ as E,x as M,S as R,B as _,C as a,H as m};
